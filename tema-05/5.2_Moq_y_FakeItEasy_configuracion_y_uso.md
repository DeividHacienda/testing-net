# 5.2 Moq y FakeItEasy: configuración y uso

## Introducción

**Moq** y **FakeItEasy** son los dos frameworks de mocking más populares para .NET. Ambos permiten crear objetos simulados fácilmente, pero con sintaxis y filosofías ligeramente diferentes.

## Instalación

### Moq
```bash
Install-Package Moq -Version 4.18.4
```

### FakeItEasy
```bash
Install-Package FakeItEasy -Version 7.3.1
```

> **Nota**: Las versiones indicadas son compatibles con .NET 4.8. Verifica la última versión estable disponible.

## Moq: Sintaxis y uso básico

### Creación de mocks

```csharp
// Crear un mock de una interfaz
var mockRepository = new Mock<IClienteRepository>();

// Usar el objeto mockeado
IClienteRepository repository = mockRepository.Object;
```

### Configuración de métodos (Setup)

```csharp
public interface IClienteRepository
{
    Cliente ObtenerPorId(int id);
    bool Guardar(Cliente cliente);
    List<Cliente> ObtenerTodos();
}

[TestMethod]
public void Ejemplo_Setup_Moq()
{
    // Arrange
    var mockRepo = new Mock<IClienteRepository>();
    
    // Setup: método con parámetro específico
    mockRepo.Setup(r => r.ObtenerPorId(1))
        .Returns(new Cliente { Id = 1, Nombre = "Juan" });
    
    // Setup: método con cualquier parámetro
    mockRepo.Setup(r => r.ObtenerPorId(It.IsAny<int>()))
        .Returns(new Cliente { Id = 0, Nombre = "Default" });
    
    // Setup: método void o que retorna bool
    mockRepo.Setup(r => r.Guardar(It.IsAny<Cliente>()))
        .Returns(true);
    
    // Act & Assert
    var cliente = mockRepo.Object.ObtenerPorId(1);
    Assert.AreEqual("Juan", cliente.Nombre);
}
```

### Verificación de llamadas

```csharp
[TestMethod]
public void Verificar_LlamadaAlMetodo()
{
    // Arrange
    var mockRepo = new Mock<IClienteRepository>();
    var service = new ClienteService(mockRepo.Object);
    
    // Act
    service.ActualizarCliente(new Cliente { Id = 1, Nombre = "Pedro" });
    
    // Assert: Verificar que se llamó Guardar exactamente 1 vez
    mockRepo.Verify(r => r.Guardar(It.IsAny<Cliente>()), Times.Once);
    
    // Verificar que nunca se llamó ObtenerTodos
    mockRepo.Verify(r => r.ObtenerTodos(), Times.Never);
}
```

### Matchers de argumentos en Moq

```csharp
mockRepo.Setup(r => r.ObtenerPorId(It.IsAny<int>())) // Cualquier entero
mockRepo.Setup(r => r.ObtenerPorId(It.Is<int>(x => x > 0))) // Condición
mockRepo.Setup(r => r.ObtenerPorId(It.IsInRange(1, 100, Range.Inclusive))) // Rango
mockRepo.Setup(r => r.Guardar(It.Is<Cliente>(c => c.Nombre != null))) // Validación
```

### Propiedades

```csharp
public interface IConfiguracion
{
    string ConnectionString { get; set; }
    int Timeout { get; }
}

[TestMethod]
public void Ejemplo_Propiedades_Moq()
{
    var mockConfig = new Mock<IConfiguracion>();
    
    // Setup de propiedad read-only
    mockConfig.SetupGet(c => c.Timeout).Returns(30);
    
    // Setup de propiedad con set
    mockConfig.SetupProperty(c => c.ConnectionString);
    mockConfig.Object.ConnectionString = "Server=test";
    
    Assert.AreEqual(30, mockConfig.Object.Timeout);
    Assert.AreEqual("Server=test", mockConfig.Object.ConnectionString);
}
```

## FakeItEasy: Sintaxis y uso básico

### Creación de fakes

```csharp
// Crear un fake de una interfaz
var fakeRepository = A.Fake<IClienteRepository>();
```

### Configuración de métodos

```csharp
[TestMethod]
public void Ejemplo_Setup_FakeItEasy()
{
    // Arrange
    var fakeRepo = A.Fake<IClienteRepository>();
    
    // Setup: método con parámetro específico
    A.CallTo(() => fakeRepo.ObtenerPorId(1))
        .Returns(new Cliente { Id = 1, Nombre = "Juan" });
    
    // Setup: método con cualquier parámetro
    A.CallTo(() => fakeRepo.ObtenerPorId(A<int>._))
        .Returns(new Cliente { Id = 0, Nombre = "Default" });
    
    // Setup: excepciones
    A.CallTo(() => fakeRepo.ObtenerPorId(999))
        .Throws<KeyNotFoundException>();
    
    // Act & Assert
    var cliente = fakeRepo.ObtenerPorId(1);
    Assert.AreEqual("Juan", cliente.Nombre);
}
```

### Verificación de llamadas

```csharp
[TestMethod]
public void Verificar_LlamadaAlMetodo_FakeItEasy()
{
    // Arrange
    var fakeRepo = A.Fake<IClienteRepository>();
    var service = new ClienteService(fakeRepo);
    
    // Act
    service.ActualizarCliente(new Cliente { Id = 1, Nombre = "Pedro" });
    
    // Assert: Verificar que se llamó Guardar
    A.CallTo(() => fakeRepo.Guardar(A<Cliente>._))
        .MustHaveHappenedOnceExactly();
    
    // Verificar que no se llamó ObtenerTodos
    A.CallTo(() => fakeRepo.ObtenerTodos())
        .MustNotHaveHappened();
}
```

### Matchers en FakeItEasy

```csharp
A.CallTo(() => fakeRepo.ObtenerPorId(A<int>._)) // Cualquier int
A.CallTo(() => fakeRepo.ObtenerPorId(A<int>.That.IsGreaterThan(0))) // Condición
A.CallTo(() => fakeRepo.Guardar(A<Cliente>.That.Matches(c => c.Nombre != null))) // Predicado
```

## Comparación Moq vs FakeItEasy

| Característica | Moq | FakeItEasy |
|----------------|-----|------------|
| **Sintaxis** | `mock.Setup(...)` | `A.CallTo(...)` |
| **Legibilidad** | Orientada a lambdas | Más cercana a lenguaje natural |
| **Curva aprendizaje** | Media | Baja |
| **Popularidad** | Muy alta | Media-Alta |
| **Rendimiento** | Excelente | Excelente |

## Ejemplo completo comparativo

```csharp
public interface IEmailService
{
    void EnviarEmail(string destinatario, string asunto, string cuerpo);
    bool ValidarEmail(string email);
}

public class NotificacionService
{
    private readonly IEmailService _emailService;
    
    public NotificacionService(IEmailService emailService)
    {
        _emailService = emailService;
    }
    
    public void NotificarCliente(string email, string mensaje)
    {
        if (_emailService.ValidarEmail(email))
        {
            _emailService.EnviarEmail(email, "Notificación", mensaje);
        }
    }
}

// ========== CON MOQ ==========
[TestMethod]
public void NotificarCliente_ConMoq()
{
    // Arrange
    var mockEmail = new Mock<IEmailService>();
    mockEmail.Setup(e => e.ValidarEmail("test@mail.com")).Returns(true);
    
    var service = new NotificacionService(mockEmail.Object);
    
    // Act
    service.NotificarCliente("test@mail.com", "Hola");
    
    // Assert
    mockEmail.Verify(e => e.EnviarEmail("test@mail.com", "Notificación", "Hola"), Times.Once);
}

// ========== CON FAKEITEASY ==========
[TestMethod]
public void NotificarCliente_ConFakeItEasy()
{
    // Arrange
    var fakeEmail = A.Fake<IEmailService>();
    A.CallTo(() => fakeEmail.ValidarEmail("test@mail.com")).Returns(true);
    
    var service = new NotificacionService(fakeEmail);
    
    // Act
    service.NotificarCliente("test@mail.com", "Hola");
    
    // Assert
    A.CallTo(() => fakeEmail.EnviarEmail("test@mail.com", "Notificación", "Hola"))
        .MustHaveHappenedOnceExactly();
}
```

## Recomendaciones

- **Moq**: Ideal si ya lo conoces o tu equipo lo usa. Excelente documentación y comunidad.
- **FakeItEasy**: Mejor para principiantes. Sintaxis más intuitiva y errores más claros.
- **Consistencia**: Elige uno y úsalo en todo el proyecto. No mezcles frameworks sin razón.

## Buenas prácticas

1. **No abuses de los mocks**: Si necesitas mockear muchas dependencias, tu clase tiene demasiadas responsabilidades
2. **Nombra claramente**: `mockClienteRepository` o `fakeEmailService`
3. **Verifica solo lo importante**: No todo comportamiento necesita verificación
4. **Setup mínimo**: Configura solo lo que el test necesita
