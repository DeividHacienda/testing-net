# 5.3 Inyección de dependencias y pruebas sin acceso a bases de datos o APIs externas

## Introducción

La **Inyección de Dependencias (DI)** es fundamental para crear código testeable. Permite reemplazar dependencias reales por mocks durante las pruebas, aislando completamente la lógica de negocio.

## Problema: Código no testeable

```csharp
public class PedidoService
{
    public bool ProcesarPedido(int pedidoId)
    {
        // Dependencias hardcodeadas - ¡IMPOSIBLE de testear!
        var dbContext = new ApplicationDbContext();
        var emailService = new SmtpEmailService();
        var paymentApi = new PayPalApiClient();
        
        var pedido = dbContext.Pedidos.Find(pedidoId);
        if (pedido == null) return false;
        
        var pago = paymentApi.ProcesarPago(pedido.Total);
        if (!pago.Exitoso) return false;
        
        emailService.EnviarConfirmacion(pedido.ClienteEmail);
        return true;
    }
}

// Imposible testear sin BD real, API de PayPal real y servidor SMTP
```

## Solución: Inyección de dependencias

### Paso 1: Definir interfaces

```csharp
public interface IPedidoRepository
{
    Pedido ObtenerPorId(int id);
    void Guardar(Pedido pedido);
}

public interface IEmailService
{
    void EnviarConfirmacion(string email, string mensaje);
}

public interface IPaymentService
{
    PaymentResult ProcesarPago(decimal monto);
}
```

### Paso 2: Inyectar dependencias

```csharp
public class PedidoService
{
    private readonly IPedidoRepository _pedidoRepository;
    private readonly IEmailService _emailService;
    private readonly IPaymentService _paymentService;
    
    // Constructor Injection (recomendado)
    public PedidoService(
        IPedidoRepository pedidoRepository,
        IEmailService emailService,
        IPaymentService paymentService)
    {
        _pedidoRepository = pedidoRepository;
        _emailService = emailService;
        _paymentService = paymentService;
    }
    
    public bool ProcesarPedido(int pedidoId)
    {
        var pedido = _pedidoRepository.ObtenerPorId(pedidoId);
        if (pedido == null) return false;
        
        var pago = _paymentService.ProcesarPago(pedido.Total);
        if (!pago.Exitoso) return false;
        
        _emailService.EnviarConfirmacion(pedido.ClienteEmail, "Pedido confirmado");
        return true;
    }
}
```

### Paso 3: Testear con mocks

```csharp
[TestClass]
public class PedidoServiceTests
{
    [TestMethod]
    public void ProcesarPedido_PedidoValido_RetornaTrue()
    {
        // Arrange
        var mockRepository = new Mock<IPedidoRepository>();
        var mockEmail = new Mock<IEmailService>();
        var mockPayment = new Mock<IPaymentService>();
        
        var pedidoTest = new Pedido 
        { 
            Id = 1, 
            Total = 100, 
            ClienteEmail = "test@mail.com" 
        };
        
        mockRepository.Setup(r => r.ObtenerPorId(1)).Returns(pedidoTest);
        mockPayment.Setup(p => p.ProcesarPago(100))
            .Returns(new PaymentResult { Exitoso = true });
        
        var service = new PedidoService(
            mockRepository.Object, 
            mockEmail.Object, 
            mockPayment.Object
        );
        
        // Act
        var resultado = service.ProcesarPedido(1);
        
        // Assert
        Assert.IsTrue(resultado);
        mockEmail.Verify(e => e.EnviarConfirmacion("test@mail.com", "Pedido confirmado"), Times.Once);
    }
    
    [TestMethod]
    public void ProcesarPedido_PagoFalla_RetornaFalse()
    {
        // Arrange
        var mockRepository = new Mock<IPedidoRepository>();
        var mockEmail = new Mock<IEmailService>();
        var mockPayment = new Mock<IPaymentService>();
        
        mockRepository.Setup(r => r.ObtenerPorId(1))
            .Returns(new Pedido { Id = 1, Total = 100 });
        
        // Simulamos fallo en el pago
        mockPayment.Setup(p => p.ProcesarPago(It.IsAny<decimal>()))
            .Returns(new PaymentResult { Exitoso = false, Error = "Tarjeta rechazada" });
        
        var service = new PedidoService(mockRepository.Object, mockEmail.Object, mockPayment.Object);
        
        // Act
        var resultado = service.ProcesarPedido(1);
        
        // Assert
        Assert.IsFalse(resultado);
        // Verificar que NO se envió email cuando falla el pago
        mockEmail.Verify(e => e.EnviarConfirmacion(It.IsAny<string>(), It.IsAny<string>()), Times.Never);
    }
}
```

## Aislamiento de base de datos

### Implementación real (producción)

```csharp
public class SqlPedidoRepository : IPedidoRepository
{
    private readonly string _connectionString;
    
    public SqlPedidoRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public Pedido ObtenerPorId(int id)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            connection.Open();
            var command = new SqlCommand("SELECT * FROM Pedidos WHERE Id = @Id", connection);
            command.Parameters.AddWithValue("@Id", id);
            
            using (var reader = command.ExecuteReader())
            {
                if (reader.Read())
                {
                    return new Pedido
                    {
                        Id = (int)reader["Id"],
                        Total = (decimal)reader["Total"],
                        ClienteEmail = reader["ClienteEmail"].ToString()
                    };
                }
            }
        }
        return null;
    }
    
    public void Guardar(Pedido pedido)
    {
        // Implementación real con SQL
    }
}
```

### Mock para pruebas

```csharp
[TestMethod]
public void Test_SinAccesoABaseDeDatos()
{
    // No necesitamos SqlPedidoRepository ni conexión real
    var mockRepository = new Mock<IPedidoRepository>();
    
    mockRepository.Setup(r => r.ObtenerPorId(It.IsAny<int>()))
        .Returns(new Pedido { Id = 1, Total = 50 });
    
    var mockEmail = new Mock<IEmailService>();
    var mockPayment = new Mock<IPaymentService>();
    mockPayment.Setup(p => p.ProcesarPago(It.IsAny<decimal>()))
        .Returns(new PaymentResult { Exitoso = true });
    
    var service = new PedidoService(
        mockRepository.Object,
        mockEmail.Object,
        mockPayment.Object
    );
    
    // Prueba completamente aislada - SIN BD
    var resultado = service.ProcesarPedido(1);
    
    Assert.IsTrue(resultado);
}
```

## Aislamiento de APIs externas

### Implementación real

```csharp
public class PayPalPaymentService : IPaymentService
{
    private readonly string _apiKey;
    private readonly string _apiUrl;
    
    public PayPalPaymentService(string apiKey, string apiUrl)
    {
        _apiKey = apiKey;
        _apiUrl = apiUrl;
    }
    
    public PaymentResult ProcesarPago(decimal monto)
    {
        // Llamada real a API de PayPal
        var client = new HttpClient();
        client.DefaultRequestHeaders.Add("Authorization", $"Bearer {_apiKey}");
        
        var content = new StringContent(
            JsonConvert.SerializeObject(new { amount = monto }),
            Encoding.UTF8,
            "application/json"
        );
        
        var response = client.PostAsync($"{_apiUrl}/payments", content).Result;
        
        if (response.IsSuccessStatusCode)
        {
            return new PaymentResult { Exitoso = true };
        }
        
        return new PaymentResult { Exitoso = false, Error = "Error en API" };
    }
}
```

### Mock para pruebas

```csharp
[TestMethod]
public void Test_SinLlamarAPIReal()
{
    // Simulamos diferentes escenarios de API sin llamarla
    var mockPayment = new Mock<IPaymentService>();
    
    // Escenario 1: Pago exitoso
    mockPayment.Setup(p => p.ProcesarPago(It.Is<decimal>(m => m < 1000)))
        .Returns(new PaymentResult { Exitoso = true });
    
    // Escenario 2: Pago rechazado por monto alto
    mockPayment.Setup(p => p.ProcesarPago(It.Is<decimal>(m => m >= 1000)))
        .Returns(new PaymentResult { Exitoso = false, Error = "Límite excedido" });
    
    // Escenario 3: Timeout de API
    mockPayment.Setup(p => p.ProcesarPago(-1))
        .Throws<TimeoutException>();
    
    // Ahora podemos testear todos los escenarios sin conexión a PayPal
}
```

## Configuración de dependencias en .NET 4.8

### Sin contenedor IoC (manual)

```csharp
// En código de producción
public class Program
{
    static void Main()
    {
        string connectionString = ConfigurationManager.ConnectionStrings["Default"].ConnectionString;
        string paypalApiKey = ConfigurationManager.AppSettings["PayPalApiKey"];
        
        IPedidoRepository repository = new SqlPedidoRepository(connectionString);
        IEmailService emailService = new SmtpEmailService();
        IPaymentService paymentService = new PayPalPaymentService(paypalApiKey, "https://api.paypal.com");
        
        var pedidoService = new PedidoService(repository, emailService, paymentService);
        
        pedidoService.ProcesarPedido(123);
    }
}
```

### Con contenedor IoC (Unity, Autofac)

```csharp
// Instalación: Install-Package Unity -Version 5.11.10

using Unity;

public class DependencyConfig
{
    public static IUnityContainer RegisterComponents()
    {
        var container = new UnityContainer();
        
        // Registrar dependencias
        container.RegisterType<IPedidoRepository, SqlPedidoRepository>();
        container.RegisterType<IEmailService, SmtpEmailService>();
        container.RegisterType<IPaymentService, PayPalPaymentService>();
        container.RegisterType<PedidoService>();
        
        return container;
    }
}

// Uso en producción
var container = DependencyConfig.RegisterComponents();
var pedidoService = container.Resolve<PedidoService>();
pedidoService.ProcesarPedido(123);
```

## Ventajas de las pruebas aisladas

✅ **Rapidez**: Pruebas en milisegundos vs. segundos
✅ **Confiabilidad**: No fallan por problemas de red o BD
✅ **Repetibilidad**: Siempre producen los mismos resultados
✅ **Simplicidad**: No requieren infraestructura de pruebas
✅ **Cobertura**: Fácil probar casos extremos y errores

## Buenas prácticas

1. **Programa contra interfaces**, nunca contra implementaciones concretas
2. **Inyecta todas las dependencias** por constructor
3. **Una responsabilidad por clase**: Si necesitas muchos mocks, refactoriza
4. **Mocks solo para dependencias externas**: No mockees DTOs o modelos de dominio
5. **Tests de integración complementarios**: Los mocks no reemplazan pruebas con BD real

## Anti-patrones a evitar

❌ **Service Locator**: No uses `ServiceLocator.GetInstance<T>()`
❌ **New en el constructor**: No instancies dependencias dentro de la clase
❌ **Clases estáticas**: Dificultan el testing (ej: `DateTime.Now`)
❌ **Singleton mal implementado**: Complica la inyección de mocks
