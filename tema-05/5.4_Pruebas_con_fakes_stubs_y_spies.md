# 5.4 Pruebas con fakes, stubs y spies

## Introducción

En testing existen diferentes tipos de objetos de prueba, cada uno con un propósito específico. Conocer las diferencias te permite elegir la herramienta adecuada para cada escenario.

## Tipos de Test Doubles

Los **Test Doubles** son objetos que reemplazan dependencias reales en las pruebas. Son como dobles de acción en las películas.

### Clasificación

1. **Dummy**: Objetos que se pasan pero nunca se usan
2. **Stub**: Devuelve respuestas predefinidas
3. **Spy**: Registra información sobre cómo fue usado
4. **Mock**: Verifica que se llamaron métodos específicos
5. **Fake**: Implementación funcional simplificada

## 1. Stubs

### ¿Qué es un Stub?

Un **stub** proporciona respuestas predefinidas a las llamadas durante la prueba. No verifica que se hayan llamado métodos, solo devuelve valores.

### Ejemplo con Moq

```csharp
public interface IStockService
{
    int ObtenerCantidadDisponible(string productoId);
    decimal ObtenerPrecio(string productoId);
}

[TestMethod]
public void CalcularTotal_ConStubs()
{
    // Arrange - Creamos stubs simples
    var stubStock = new Mock<IStockService>();
    
    // Stub: siempre devuelve 50
    stubStock.Setup(s => s.ObtenerCantidadDisponible(It.IsAny<string>()))
        .Returns(50);
    
    // Stub: devuelve precio específico por producto
    stubStock.Setup(s => s.ObtenerPrecio("PROD001")).Returns(100m);
    stubStock.Setup(s => s.ObtenerPrecio("PROD002")).Returns(200m);
    
    var service = new CarritoService(stubStock.Object);
    
    // Act
    var total = service.CalcularTotal("PROD001", 2);
    
    // Assert
    Assert.AreEqual(200m, total); // 100 * 2
    
    // NO verificamos si se llamó al stub - esa no es su función
}
```

### Stub manual (sin framework)

```csharp
// Implementación manual de un stub
public class StockServiceStub : IStockService
{
    private readonly Dictionary<string, int> _cantidades;
    private readonly Dictionary<string, decimal> _precios;
    
    public StockServiceStub()
    {
        _cantidades = new Dictionary<string, int>();
        _precios = new Dictionary<string, decimal>();
    }
    
    public void ConfigurarCantidad(string productoId, int cantidad)
    {
        _cantidades[productoId] = cantidad;
    }
    
    public void ConfigurarPrecio(string productoId, decimal precio)
    {
        _precios[productoId] = precio;
    }
    
    public int ObtenerCantidadDisponible(string productoId)
    {
        return _cantidades.ContainsKey(productoId) ? _cantidades[productoId] : 0;
    }
    
    public decimal ObtenerPrecio(string productoId)
    {
        return _precios.ContainsKey(productoId) ? _precios[productoId] : 0m;
    }
}

[TestMethod]
public void Test_ConStubManual()
{
    // Arrange
    var stubStock = new StockServiceStub();
    stubStock.ConfigurarCantidad("PROD001", 100);
    stubStock.ConfigurarPrecio("PROD001", 50m);
    
    var service = new CarritoService(stubStock);
    
    // Act
    var total = service.CalcularTotal("PROD001", 3);
    
    // Assert
    Assert.AreEqual(150m, total);
}
```

## 2. Spies

### ¿Qué es un Spy?

Un **spy** registra información sobre cómo fue usado (qué métodos se llamaron, con qué parámetros, cuántas veces). Es como un stub que además espía.

### Ejemplo con Moq

```csharp
public interface ILogger
{
    void Log(string mensaje);
    void LogError(string mensaje, Exception ex);
}

[TestMethod]
public void ProcesarPedido_LoggeaCantidadCorrecta()
{
    // Arrange - Mock actúa como spy
    var spyLogger = new Mock<ILogger>();
    var service = new PedidoService(spyLogger.Object);
    
    // Act
    service.ProcesarPedido(1);
    service.ProcesarPedido(2);
    
    // Assert - Verificamos las interacciones (comportamiento de spy)
    spyLogger.Verify(l => l.Log(It.IsAny<string>()), Times.Exactly(2));
    spyLogger.Verify(l => l.Log("Procesando pedido 1"), Times.Once);
    spyLogger.Verify(l => l.LogError(It.IsAny<string>(), It.IsAny<Exception>()), Times.Never);
}
```

### Spy manual (sin framework)

```csharp
public class LoggerSpy : ILogger
{
    public List<string> MensajesLogueados { get; } = new List<string>();
    public List<string> ErroresLogueados { get; } = new List<string>();
    public int VecesLlamadoLog { get; private set; }
    public int VecesLlamadoLogError { get; private set; }
    
    public void Log(string mensaje)
    {
        VecesLlamadoLog++;
        MensajesLogueados.Add(mensaje);
    }
    
    public void LogError(string mensaje, Exception ex)
    {
        VecesLlamadoLogError++;
        ErroresLogueados.Add($"{mensaje}: {ex.Message}");
    }
}

[TestMethod]
public void Test_ConSpyManual()
{
    // Arrange
    var spyLogger = new LoggerSpy();
    var service = new PedidoService(spyLogger);
    
    // Act
    service.ProcesarPedido(1);
    service.ProcesarPedido(2);
    
    // Assert - Inspeccionamos el spy
    Assert.AreEqual(2, spyLogger.VecesLlamadoLog);
    Assert.AreEqual(0, spyLogger.VecesLlamadoLogError);
    Assert.IsTrue(spyLogger.MensajesLogueados.Contains("Procesando pedido 1"));
}
```

## 3. Fakes

### ¿Qué es un Fake?

Un **fake** es una implementación funcional pero simplificada. No es un mock, es código real pero más simple que la versión de producción.

### Ejemplo: Fake Repository en memoria

```csharp
public interface IClienteRepository
{
    Cliente ObtenerPorId(int id);
    void Guardar(Cliente cliente);
    List<Cliente> ObtenerTodos();
    void Eliminar(int id);
}

// Implementación REAL con SQL Server
public class SqlClienteRepository : IClienteRepository
{
    private readonly string _connectionString;
    
    public SqlClienteRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public Cliente ObtenerPorId(int id)
    {
        // Acceso real a base de datos
        using (var connection = new SqlConnection(_connectionString))
        {
            // ... código SQL real
        }
    }
    
    // ... más métodos con SQL real
}

// FAKE para pruebas - Implementación en memoria
public class FakeClienteRepository : IClienteRepository
{
    private readonly Dictionary<int, Cliente> _clientes = new Dictionary<int, Cliente>();
    private int _nextId = 1;
    
    public Cliente ObtenerPorId(int id)
    {
        return _clientes.ContainsKey(id) ? _clientes[id] : null;
    }
    
    public void Guardar(Cliente cliente)
    {
        if (cliente.Id == 0)
        {
            cliente.Id = _nextId++;
        }
        _clientes[cliente.Id] = cliente;
    }
    
    public List<Cliente> ObtenerTodos()
    {
        return _clientes.Values.ToList();
    }
    
    public void Eliminar(int id)
    {
        if (_clientes.ContainsKey(id))
        {
            _clientes.Remove(id);
        }
    }
}

[TestMethod]
public void GuardarCliente_ConFakeRepository()
{
    // Arrange - Usamos el fake en lugar de mock
    var fakeRepo = new FakeClienteRepository();
    var service = new ClienteService(fakeRepo);
    
    // Act
    var cliente = new Cliente { Nombre = "Juan", Email = "juan@mail.com" };
    service.RegistrarCliente(cliente);
    
    // Assert
    var clienteGuardado = fakeRepo.ObtenerPorId(1);
    Assert.IsNotNull(clienteGuardado);
    Assert.AreEqual("Juan", clienteGuardado.Nombre);
    
    // El fake tiene comportamiento REAL, solo que en memoria
    var todos = fakeRepo.ObtenerTodos();
    Assert.AreEqual(1, todos.Count);
}
```

### Fake para sistema de archivos

```csharp
public interface IFileSystem
{
    string LeerArchivo(string ruta);
    void GuardarArchivo(string ruta, string contenido);
    bool ArchivoExiste(string ruta);
}

// FAKE - Sistema de archivos en memoria
public class FakeFileSystem : IFileSystem
{
    private readonly Dictionary<string, string> _archivos = new Dictionary<string, string>();
    
    public string LeerArchivo(string ruta)
    {
        if (!_archivos.ContainsKey(ruta))
            throw new FileNotFoundException($"Archivo no encontrado: {ruta}");
        
        return _archivos[ruta];
    }
    
    public void GuardarArchivo(string ruta, string contenido)
    {
        _archivos[ruta] = contenido;
    }
    
    public bool ArchivoExiste(string ruta)
    {
        return _archivos.ContainsKey(ruta);
    }
}

[TestMethod]
public void ExportarReporte_GuardaArchivo()
{
    // Arrange
    var fakeFS = new FakeFileSystem();
    var service = new ReporteService(fakeFS);
    
    // Act
    service.ExportarReporte("reporte.txt", "Contenido del reporte");
    
    // Assert
    Assert.IsTrue(fakeFS.ArchivoExiste("reporte.txt"));
    Assert.AreEqual("Contenido del reporte", fakeFS.LeerArchivo("reporte.txt"));
}
```

## Comparación: Stub vs Spy vs Mock vs Fake

| Característica | Stub | Spy | Mock | Fake |
|----------------|------|-----|------|------|
| **Devuelve valores** | ✅ Sí | ✅ Sí | ✅ Sí | ✅ Sí |
| **Verifica llamadas** | ❌ No | ✅ Sí | ✅ Sí | ❌ No |
| **Comportamiento real** | ❌ No | ❌ No | ❌ No | ✅ Sí (simplificado) |
| **Complejidad** | Baja | Media | Media | Alta |
| **Cuándo usar** | Solo necesitas datos | Necesitas verificar interacciones | Testing de comportamiento | Necesitas lógica real simple |

## Cuándo usar cada uno

### Usa STUB cuando:
```csharp
// Solo necesitas que devuelva un valor
[TestMethod]
public void CalcularDescuento_ConPrecioFijo()
{
    var stubCatalogo = new Mock<ICatalogoService>();
    stubCatalogo.Setup(c => c.ObtenerPrecio("PROD001")).Returns(100m);
    // No nos importa SI se llamó, solo QUÉ devuelve
}
```

### Usa SPY cuando:
```csharp
// Necesitas verificar cuántas veces se llamó algo
[TestMethod]
public void EnviarNotificaciones_LlamaEmailPorCadaCliente()
{
    var spyEmail = new Mock<IEmailService>();
    var service = new NotificacionService(spyEmail.Object);
    
    service.NotificarClientes(new[] { "email1@test.com", "email2@test.com" });
    
    // Verificamos comportamiento
    spyEmail.Verify(e => e.Enviar(It.IsAny<string>()), Times.Exactly(2));
}
```

### Usa MOCK cuando:
```csharp
// Necesitas verificar comportamiento específico
[TestMethod]
public void ProcesarPago_FallaAlGuardar_NoEnviaEmail()
{
    var mockRepo = new Mock<IPedidoRepository>();
    var mockEmail = new Mock<IEmailService>();
    
    mockRepo.Setup(r => r.Guardar(It.IsAny<Pedido>())).Throws<Exception>();
    
    var service = new PedidoService(mockRepo.Object, mockEmail.Object);
    
    service.ProcesarPedido(new Pedido());
    
    // Verificamos que NO se llamó
    mockEmail.Verify(e => e.Enviar(It.IsAny<string>()), Times.Never);
}
```

### Usa FAKE cuando:
```csharp
// Necesitas comportamiento real pero sin infraestructura
[TestMethod]
public void CarritoDeCompras_AgregaYEliminaProductos()
{
    // Fake repository con lógica real en memoria
    var fakeRepo = new FakeCarritoRepository();
    var service = new CarritoService(fakeRepo);
    
    service.AgregarProducto("PROD001", 2);
    service.AgregarProducto("PROD002", 1);
    service.EliminarProducto("PROD001");
    
    var items = fakeRepo.ObtenerTodos();
    Assert.AreEqual(1, items.Count); // Lógica real funcionó
}
```

## Ventajas y desventajas

### Stubs
✅ Simples y rápidos
✅ Buenos para testing de estado
❌ No verifican comportamiento

### Spies
✅ Verifican interacciones
✅ Útiles para logging y auditoría
❌ Pueden hacer tests frágiles

### Mocks
✅ Verificación precisa de comportamiento
✅ Excelentes para testing de interacciones
❌ Pueden sobrespecificar y hacer tests frágiles

### Fakes
✅ Comportamiento real y completo
✅ Reutilizables entre tests
✅ Buenos para tests de integración ligeros
❌ Requieren más código
❌ Deben mantenerse sincronizados con la implementación real

## Buenas prácticas

1. **Preferir stubs para casos simples**: Si solo necesitas un valor de retorno, usa stub
2. **Mocks con moderación**: Solo verifica lo importante, no cada llamada
3. **Fakes para subsistemas completos**: BD en memoria, sistema de archivos fake, etc.
4. **Nombra claramente**: `stubPriceService`, `spyLogger`, `mockRepository`, `fakeDatabase`
5. **Un tipo por test**: No mezcles stub, spy y mock en el mismo test si puedes evitarlo

## Ejemplo completo integrando conceptos

```csharp
[TestClass]
public class PedidoServiceIntegrationTests
{
    [TestMethod]
    public void ProcesarPedido_EscenarioCompleto()
    {
        // FAKE: Base de datos en memoria (comportamiento real)
        var fakeRepo = new FakeClienteRepository();
        fakeRepo.Guardar(new Cliente { Id = 1, Nombre = "Juan", Credito = 1000m });
        
        // STUB: Servicio de precios (solo devuelve valores)
        var stubPrecios = new Mock<IPrecioService>();
        stubPrecios.Setup(p => p.ObtenerPrecio("PROD001")).Returns(100m);
        
        // SPY: Logger (queremos saber si se logueó)
        var spyLogger = new LoggerSpy();
        
        // MOCK: Email (verificamos que se envió)
        var mockEmail = new Mock<IEmailService>();
        
        var service = new PedidoService(fakeRepo, stubPrecios.Object, spyLogger, mockEmail.Object);
        
        // Act
        service.ProcesarPedido(1, "PROD001", 5);
        
        // Assert
        Assert.AreEqual(500m, fakeRepo.ObtenerPorId(1).Credito); // Fake funcionó
        Assert.IsTrue(spyLogger.MensajesLogueados.Any(m => m.Contains("Pedido procesado"))); // Spy capturó
        mockEmail.Verify(e => e.Enviar(It.IsAny<string>()), Times.Once); // Mock verificó
    }
}
```
